# General class

class LinearProblem:
    """Class for solving a linear variational problem of the form :math:`a(u, v) = L(v) \\,  \\forall v \\in V`
    using PETSc as a linear algebra backend.

    """

    def __init__(self, a: ufl.Form, L: ufl.Form, bcs: typing.List[DirichletBCMetaClass] = [],
                 u: _Function = None, petsc_options={}, form_compiler_params={}, jit_params={}):
        """Initialize solver for a linear variational problem.

        Args:
            a: A bilinear UFL form, the left hand side of the variational problem.
            L: A linear UFL form, the right hand side of the variational problem.
            bcs: A list of Dirichlet boundary conditions.
            u: The solution function. It will be created if not provided.
            petsc_options: Parameters that is passed to the linear
                algebra backend PETSc. For available choices for the
                'petsc_options' kwarg, see the `PETSc documentation
                <https://petsc4py.readthedocs.io/en/stable/manual/ksp/>`_.
            form_compiler_params: Parameters used in FFCx compilation of
                this form. Run ``ffcx --help`` at the commandline to see
                all available options.
            jit_params: Parameters used in CFFI JIT compilation of C
                code generated by FFCx. See `python/dolfinx/jit.py` for
                all available parameters. Takes priority over all other
                parameter values.

        Example::

            problem = LinearProblem(a, L, [bc0, bc1], petsc_options={"ksp_type": "preonly", "pc_type": "lu"})

        """
        self._a = _create_form(a, form_compiler_params=form_compiler_params, jit_params=jit_params)
        self._A = create_matrix(self._a)

        self._L = _create_form(L, form_compiler_params=form_compiler_params, jit_params=jit_params)
        self._b = create_vector(self._L)

        if u is None:
            # Extract function space from TrialFunction (which is at the
            # end of the argument list as it is numbered as 1, while the
            # Test function is numbered as 0)
            self.u = _Function(a.arguments()[-1].ufl_function_space())
        else:
            self.u = u

        self._x = _cpp.la.petsc.create_vector_wrap(self.u.x)
        self.bcs = bcs

        self._solver = PETSc.KSP().create(self.u.function_space.mesh.comm)
        self._solver.setOperators(self._A)

        # Give PETSc solver options a unique prefix
        problem_prefix = f"dolfinx_solve_{id(self)}"
        self._solver.setOptionsPrefix(problem_prefix)

        # Set PETSc options
        opts = PETSc.Options()
        opts.prefixPush(problem_prefix)
        for k, v in petsc_options.items():
            opts[k] = v
        opts.prefixPop()
        self._solver.setFromOptions()

        # Set matrix and vector PETSc options
        self._A.setOptionsPrefix(problem_prefix)
        self._A.setFromOptions()
        self._b.setOptionsPrefix(problem_prefix)
        self._b.setFromOptions()

    def solve(self) -> _Function:
        """Solve the problem."""

        # Assemble lhs
        self._A.zeroEntries()
        _assemble_matrix_mat(self._A, self._a, bcs=self.bcs)
        self._A.assemble()

        # Assemble rhs
        with self._b.localForm() as b_loc:
            b_loc.set(0)
        assemble_vector(self._b, self._L)

        # Apply boundary conditions to the rhs
        apply_lifting(self._b, [self._a], bcs=[self.bcs])
        self._b.ghostUpdate(addv=PETSc.InsertMode.ADD, mode=PETSc.ScatterMode.REVERSE)
        set_bc(self._b, self.bcs)

        # Solve linear system and update ghost values in the solution
        self._solver.solve(self._b, self._x)
        self.u.x.scatter_forward()

        return self.u

    @property
    def L(self) -> FormMetaClass:
        """The compiled linear form"""
        return self._L

    @property
    def a(self) -> FormMetaClass:
        """The compiled bilinear form"""
        return self._a

    @property
    def A(self) -> PETSc.Mat:
        """Matrix operator"""
        return self._A

    @property
    def b(self) -> PETSc.Vec:
        """Right-hand side vector"""
        return self._b

    @property
    def solver(self) -> PETSc.KSP:
        """Linear solver object"""
        return self._solver


class NonlinearProblem:
    """Nonlinear problem class for solving the non-linear problem
    :math:`F(u, v) = 0 \\ \\forall v \\in V` using PETSc as the linear algebra
    backend.

    """

    def __init__(self, F: ufl.form.Form, u: _Function, bcs: typing.List[DirichletBCMetaClass] = [],
                 J: ufl.form.Form = None, form_compiler_params={}, jit_params={},):
        """Initialize solver for solving a non-linear problem using Newton's method, :math:`dF/du(u) du = -F(u)`.

        Args:
            F: The PDE residual F(u, v)
            u: The unknown
            bcs: List of Dirichlet boundary conditions
            J: UFL representation of the Jacobian (Optional)
            form_compiler_params: Parameters used in FFCx
                compilation of this form. Run ``ffcx --help`` at the
                commandline to see all available options.
            jit_params: Parameters used in CFFI JIT compilation of C
                code generated by FFCx. See ``python/dolfinx/jit.py``
                for all available parameters. Takes priority over all
                other parameter values.

        Example::

            problem = LinearProblem(F, u, [bc0, bc1])

        """
        self._L = _create_form(F, form_compiler_params=form_compiler_params,
                               jit_params=jit_params)

        # Create the Jacobian matrix, dF/du
        if J is None:
            V = u.function_space
            du = ufl.TrialFunction(V)
            J = ufl.derivative(F, u, du)

        self._a = _create_form(J, form_compiler_params=form_compiler_params,
                               jit_params=jit_params)
        self.bcs = bcs

    @property
    def L(self) -> FormMetaClass:
        """Compiled linear form (the residual form)"""
        return self._L

    @property
    def a(self) -> FormMetaClass:
        """Compiled bilinear form (the Jacobian form)"""
        return self._a

    def form(self, x: PETSc.Vec):
        """This function is called before the residual or Jacobian is
        computed. This is usually used to update ghost values.

        Args:
           x: The vector containing the latest solution

        """
        x.ghostUpdate(addv=PETSc.InsertMode.INSERT, mode=PETSc.ScatterMode.FORWARD)

    def F(self, x: PETSc.Vec, b: PETSc.Vec):
        """Assemble the residual F into the vector b.

        Args:
            x: The vector containing the latest solution
            b: Vector to assemble the residual into

        """
        # Reset the residual vector
        with b.localForm() as b_local:
            b_local.set(0.0)
        assemble_vector(b, self._L)

        # Apply boundary condition
        apply_lifting(b, [self._a], bcs=[self.bcs], x0=[x], scale=-1.0)
        b.ghostUpdate(addv=PETSc.InsertMode.ADD, mode=PETSc.ScatterMode.REVERSE)
        set_bc(b, self.bcs, x, -1.0)

    def J(self, x: PETSc.Vec, A: PETSc.Mat):
        """Assemble the Jacobian matrix.

        Args:
            x: The vector containing the latest solution

        """
        A.zeroEntries()
        _assemble_matrix_mat(A, self._a, self.bcs)
        A.assemble()

# My func1
def NonLinear_Solver(problem, params={}, options={},report = False):

    params0 = {
        'convergence_criterion': 'incremental',
        'tolerance': 1E-6,
        }
    params0.update(params)

    options0 = {
        "ksp_type": "cg",
        "pc_type": "gamg",
        'pc_factor_mat_solver_type': 'mumps',
        }
    options0.update(options)

    solver = nls.petsc.NewtonSolver(MPI.COMM_WORLD, problem=problem)

    solver.convergence_criterion = params0['convergence_criterion']
    solver.rtol = params0['tolerance']
    solver.report = report

    ksp = solver.krylov_solver
    opts = petsc4py.PETSc.Options()
    option_prefix = ksp.getOptionsPrefix()
    opts[f"{option_prefix}ksp_type"] = options0['ksp_type']
    opts[f"{option_prefix}pc_type"] = options0['pc_type']
    opts[f"{option_prefix}pc_factor_mat_solver_type"] = options0['pc_factor_mat_solver_type']
    ksp.setFromOptions()
    return solver

# My func2
def NonLinear_Solver2(problem, params={}, options={},report = False):

    params0 = {
        'convergence_criterion': 'incremental',
        'tolerance': 1E-6,
        }
    params0.update(params)

    options0 = {
        "ksp_type": "cg",
        "pc_type": "gamg",
        'pc_factor_mat_solver_type': 'mumps',
        }
    options0.update(options)

    solver = nls.petsc.NewtonSolver(MPI.COMM_WORLD, problem=problem)

    solver.convergence_criterion = params0['convergence_criterion']
    solver.rtol = params0['tolerance']
    solver.report = report

    lin_solver = solver.krylov_solver
    KSP_type = petsc4py.PETSc.KSP.Type
    lin_solver.setType(KSP_type.CG)

    PC_type = petsc4py.PETSc.PC.Type
    PC = lin_solver.getPC()
    PC.setType(PC_type.GAMG)

    return solver

# My func3:
def Linear_Solver(domain, A_assembled, params={}):
    solver = petsc4py.PETSc.KSP().create(domain.comm)
    solver.setOperators(A_assembled)

    KSP_type = petsc4py.PETSc.KSP.Type
    solver.setType(KSP_type.PREONLY)

    PC_type = petsc4py.PETSc.PC.Type
    PC = solver.getPC()
    PC.setType(PC_type.LU)
    return solver

# Stokes
solver1 = petsc4py.PETSc.KSP().create(domain.comm)
solver1.setOperators(A1)
solver1.setType(petsc4py.PETSc.KSP.Type.BCGS)
pc1 = solver1.getPC()
pc1.setType(petsc4py.PETSc.PC.Type.HYPRE)
pc1.setHYPREType("boomeramg")

 for t in np.arange(0, T + dt, dt):
        u0.interpolate(uS)
        p0.interpolate(pS)
        file.write_function([u0,p0], t)

        # Step 1
        # Cleaning linear_form solution
        with b1.localForm() as loc_b1:
            loc_b1.set(0)
        fem.petsc.assemble_vector(b1, L1)
        # Apply Dirichlet to the b
        fem.petsc.apply_lifting(b1, [a1], [bcsV])
        b1.ghostUpdate(
            addv=petsc4py.PETSc.InsertMode.ADD_VALUES,
            mode=petsc4py.PETSc.ScatterMode.REVERSE,
            )
        fem.petsc.set_bc(b1, bcsV)
        # Solving
        solver1.solve(b1, uS.vector)
        uS.x.scatter_forward()